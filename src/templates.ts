import {IIconList} from "./interfaces";

const clean = (obj: IIconList): string => {
    const cleaned = JSON.stringify(obj, null, 4);
    return cleaned.replace(/^[\t ]*"[^:\n\r]+(?<!\\)":/gm, match => {
        return match.replace(/"/g, "");
    });
};

const prefixedClass: string = "icon-${icon}";
const warningComment: string = `/*
*   DO NOT MAKE CHANGES TO THIS FILE 
*   THIS FILE WAS GENERATED BY REACT-SCRIPTS-SVG
*   https://github.com/wllkle/react-scripts-svg
*/`;

export const getTemplate = (
    content: IIconList,
    name: string,
    typescript: boolean,
    defaultExport: boolean,
    propTypes: boolean
): string => {
    const ts = (value: string) => typescript ? value : "";

    return `${warningComment}

import React, {CSSProperties} from "react";${propTypes ? `\nimport PropTypes from "prop-types";` : ""}

import {iconList, IconTypesArray${ts(", IconTypes, INode")}} from "./defs";

const printableElements${ts(": string[]")} = ["title", "style"];
${ts(`\ninterface IconProps {
    name: IconTypes,
    className?: string | string[],
    style?: CSSProperties
}\n`)}
const buildClassName = (className${ts(": string | string[]")}, icon${ts(": string")} = "")${ts(": string")} => {
    const classNames = ["icon", \`${prefixedClass}\`];
    if (Array.isArray(className)) {
        classNames.concat(className);
    } else {
        classNames.push(className);
    }
    return classNames.map(c => c && c.trim()).join(" ");
}

const renderChildNodes = (nodes${ts(": INode[]")}) => (
    <>
        {nodes.map((node${ts(": INode")}) => {
            const {name, attributes, children} = node;
            const Tag = name.toString();
            const id = Math.random().toString(36).substring(2, 8);
            
            if (printableElements.includes(name)) {
                if (node.children.length > 0) {
                    const {value} = node.children[0]${ts("\n")}
                    ${ts("// @ts-ignore")}
                    return (<Tag key={id}>{value}</Tag>);
                }
            }${ts("\n")}
            ${ts("// @ts-ignore")}
            return (<Tag key={id} {...attributes}>{renderChildNodes(children)}</Tag>);
        })}
    </>
);

export const ${name} = (props${ts(": IconProps")}) => {
    const {name, className, style} = props;
    const iconData = iconList[name] ? iconList[name] : null;

    let svgProps = {
        className: buildClassName(className, iconData.name ? iconData.name : undefined)
    };
    
    if (style) svgProps["style"] = style;

    if (iconData) {
        const {viewBox, element} = iconData;
        svgProps["viewBox"] = viewBox;

        return (
            <svg {...svgProps}>
                {renderChildNodes(element)}
            </svg>
        );
    }
    
    return (
        <svg {...svgProps}/>
    );
}${propTypes ? `\n\n${name}${getPropTypes}` : ""}${defaultExport ? `\n\nexport default ${name}` : ""}

export {IconTypesArray${ts(", IconTypes")}} from "./defs"
`;
}

const getPropTypes: string = `.propTypes = {
    name: PropTypes.oneOf(IconTypesArray),
    className: PropTypes.oneOf([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
    ])
}`

export const getDefsTemplate = (content: IIconList, typescript: boolean) => {
    const iconList = clean(content)
    const iconTypes = Object.keys(content).map(key => `"${key}"`)
    const iconTypesArray = iconTypes.join(",\n\t")

    if (typescript) {
        const iconTypesUnion = iconTypes.join(" |\n\t")

        return `export interface INode {
    name: string,
    type: string,
    value: string,
    attributes: object,
    children: INode[]
}

interface IIconList {
    [key: string]: {
        name: string,
        viewBox: string,
        element: INode[]
    }
}

export const iconList: IIconList = ${iconList};
        
export type IconTypes = ${iconTypesUnion};

export const IconTypesArray: string[] = [
    ${iconTypesArray}
];
`;
    }

    return `export const iconList = ${iconList};
    
export const IconTypesArray = [
    ${iconTypesArray}
];
`;
}
