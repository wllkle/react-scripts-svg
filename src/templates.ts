import {IIconList} from "./interfaces";

const clean = (obj: IIconList): string => {
    const cleaned = JSON.stringify(obj, null, 4);
    return cleaned.replace(/^[\t ]*"[^:\n\r]+(?<!\\)":/gm, match => {
        return match.replace(/"/g, "");
    });
};

export const getTemplate = (
    content: IIconList,
    name: string,
    typescript: boolean,
    defaultExport: boolean,
    className: string,
    propTypes: boolean
): string => {
    if (typescript) return templateTs(content, name, defaultExport, className, propTypes)
    return templateJs(content, name, defaultExport, className, propTypes)
}

const templateJs = (content: IIconList, name: string, defaultExport: boolean, className: string, propTypes: boolean): string => {
    const iconList = clean(content)
    const iconTypes = Object.keys(content).map(key => `"${key}"`).join(",\n\t")

    // prefixed icon string must be generated outside back-ticked string
    const prefixedIconName = "`${DEFAULT_CLASSNAME}-${icon}`"

    return `// GENERATED BY REACT-SCRIPTS-SVG
// DO NOT MAKE CHANGES TO THIS FILE
import React from "react";${propTypes ? `\nimport PropTypes from "prop-types";` : ""}
    
export const IconTypesArray = [
    ${iconTypes}
];

const DEFAULT_CLASSNAME = "${className}";

const buildClassName = (className, icon) => {
    const classNames = [DEFAULT_CLASSNAME];
    if (icon !== "") {
        classNames.push(${prefixedIconName});
    }
    
    if (Array.isArray(className)) {
        classNames.concat(className);
    } else {
        classNames.push(className);
    }
    
    return classNames.join(" ");
}

const renderChildNodes = (nodes) => (
    <>
        {nodes.map(node => {
            const {name, attributes, children} = node;
            if (name === "title") return null;
            const Tag = name.toString();
            const id = Math.random().toString(36).substring(2, 8);
            
            return (
                <Tag key={id} {...attributes}>{renderChildNodes(children)}</Tag>
            );
        })}
    </>
);

${defaultExport ? "" : "export "}const ${name} = (props) => {
    const {name, className, style} = props;
    const iconData = iconList[name] ? iconList[name] : null;
    
    if (iconData) {
        const {viewBox, element} = iconData;
        const classNames = buildClassName(className, iconData.name);
        
        return (
            <svg viewBox={viewBox} className={classNames} style={style}>
                {renderChildNodes(element)}
            </svg>
        );
    }
    
    const classNames = buildClassName(className, iconData.name);
    
    return (
        <svg className={classNames} style={style}/>
    );
}${propTypes ? `\n\n${name}${getPropTypes}` : ""}
    
const iconList = ${iconList};${defaultExport ? `\n\nexport default ${name}` : ""}
`;
}

const templateTs = (content: IIconList, name: string, defaultExport: boolean, className: string, propTypes: boolean): string => {
    const iconList = clean(content)
    const iconTypes = Object.keys(content).map(key => `"${key}"`)
    const iconTypesUnion = iconTypes.join(" |\n\t")
    const iconTypesArray = iconTypes.join(",\n\t")

    // prefixed icon string must be generated outside back-ticked string
    const prefixedIconName = "`${DEFAULT_CLASSNAME}-${icon}`"

    return `// GENERATED BY REACT-SCRIPTS-SVG
// DO NOT MAKE CHANGES TO THIS FILE
import React, {CSSProperties} from "react";${propTypes ? `\nimport PropTypes from "prop-types";` : ""}

export type IconTypes = ${iconTypesUnion};

export const IconTypesArray: string[] = [
    ${iconTypesArray}
];

interface IconProps {
    name: IconTypes,
    className?: string | string[],
    style?: CSSProperties
}

interface INode {
    name: string,
    type: string,
    value: string,
    attributes: object,
    children: INode[]
}

interface IIconList {
    [key: string]: {
        name: string,
        viewBox: string,
        element: INode[]
    }
}

const DEFAULT_CLASSNAME = "${className}";

const buildClassName = (className: string | string[], icon: string = ""): string => {
    const classNames = [DEFAULT_CLASSNAME];
    if (icon !== "") {
        classNames.push(${prefixedIconName});
    }
    
    if (Array.isArray(className)) {
        classNames.concat(className);
    } else {
        classNames.push(className);
    }
    
    return classNames.join(" ");
}

const renderChildNodes = (nodes: INode[]) => (
    <>
        {nodes.map((node: INode) => {
            const {name, attributes, children} = node;
            if (name === "title") return null;
            const Tag = name.toString();
            const id = Math.random().toString(36).substring(2, 8);
            
            // @ts-ignore
            return (<Tag key={id} {...attributes}>{renderChildNodes(children)}</Tag>);
        })}
    </>
);

${defaultExport ? "" : "export "}const ${name} = (props: IconProps) => {
    const {name, className, style} = props;
    const iconData = iconList[name] ? iconList[name] : null;    

    if (iconData) {
        const {viewBox, element} = iconData;
        const classNames = buildClassName(className, iconData.name);

        return (
            <svg viewBox={viewBox} className={classNames} style={style}>
                {renderChildNodes(element)}
            </svg>
        );
    }
    
    const classNames = buildClassName(className);
    
    return (
        <svg className={classNames} style={style}/>
    );
}${propTypes ? `\n\n${name}${getPropTypes}` : ""}

const iconList: IIconList = ${iconList};${defaultExport ? `\n\nexport default ${name}` : ""}
`;
}

const getPropTypes: string = `.propTypes = {
    name: PropTypes.oneOf(IconTypesArray),
    className: PropTypes.oneOf([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
    ]),
    style: PropTypes.object
}`
